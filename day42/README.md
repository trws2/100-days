# Day 42

- continue reading Modern System Design from educative.io
  - Abstraction
    - Remote procedure call (RPC)
      - Components of an RPC system
      - The workflow of an RPC
    - Consistency
      - Eventual consistency
      - Causal consistency
      - Sequential consistency
      - Strict consistency or linearizability
    - Failure Models
      - Fail-stop
      - Crash
      - Omission failure
      - Temporal failure
      - Byzantine failure
    - Non Functional System Characteristics
      - Availability
      - Reliability
      - Scalability
      - Maintainability
      - Fault Tolerance
    - Back-of-the-envolope calculations (BOTEC)
    - Data center server type
      - Web servers
      - Application servers
      - Storage servers
    - Server specification dimension
      - processor
      - number of cores (e.g. 24)
      - RAM (GB)
      - L3 cache (MB)
      - storage capacity (TB)
    - Important latency (ns)
      - L1 cache: 0.9 ns
      - L2 cache: 2.8 ns
      - L3 cache: 12.9 ns
      - main memory reference: 100 ns
      - compress 1KB with snzip: 3000 (3μs)
      - Read 1MB sequentially from memory: 9000 (9μs)
      - Read 1MB sequentially from SSD: 200,000 (200μs)
      - Round trip within same datacenter: 500,000 (500μs)
      - Read 1M sequentially from SSD with speed ~1GB/sec SSD: 1,000,000 (1ms)
      - Disk seek: 4,000,000 (4ms)
      - Read 1MB sequnetially from disk: 2,000,000 (2ms)
      - Send packet from SF to NYC: 71,000,000 (71ms)
    - Important Rates
      - QPS handled by MySQL: 1000
      - QPS handled by key-value store: 10,000
      - QPS handled by server cache: 100,000 - 1,000,000 (1M)
    - Request estimation in system design
      - CPU_time_per_program = number_of_instructions_per_program * clock_cycles_per_instruction * CPU_time_per_clock_cycle
      - suppose we have server with 64 cores with CPU frequency being 3.5GHz
        - CPU time per cycle = 1 / (3.5 x 10^9) second
        - Assume each instruction take 1 clock cycle
        - Assume we have 3.5 x 10^6 instructions per request
        - CPU time per request  = 3.5 x 10^6 x 1 / (3.5 x 10^9) second = 0.001 second
        - Number of requests can be processed within 1 second with 1 core is 1000
        - Number of requests can be processed with 1 second with 64 cores is 64,000
    - Resource Estimation
      - Server requirement to process requests
        - Need to estimate request per second.
        - We have total requests per day, we can compute request per second with assumption
          - assume eventually distributed
          - assume 80% of peak traffic happens in 20% of time
        - We can log the historical traffic stat and get the peak traffic number by looking at historical number
        - We have estimated the number of requests a server can process (RPS), we have estimate the server needed by: S = number_of_requests_per_second / RPS
        - We can get the hourly cost, C, of renting a server instance from AWS. We, thus, get the hourly cost handle our requests by: C * S
      - Storage requirements
        - store data such as texts, images, vidoes, audios
      - Bandwidth requirements
        - from storage estimation, you can get incoming traffic per second (post tweets) and outgoing traffic per second (view tweets). Sum them up is the bandwidth requirement assuming there is no compression
        - note that we use bits or bytes to measure bandwidth, or Gbps (billions of bits per second).
